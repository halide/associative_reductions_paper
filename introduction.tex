Halide \cite{Ragan-Kelley:2013:HLC:2491956.2462176} is a domain-specific language designed for fast-image processing and computational photography. Halide decouples the \emph{algorithm}, which defines the values computed, and the \emph{schedule}, which defines how the values are computed, that allows programmers to explore different schedules with guaranteed correctness and consistency: different schedules on the same algorithm are guaranteed to produce the same results. Although, data-parallel operations, such as resizing an image, can be naturally parallelized or vectorized in Halide, Halide does not support first-class parallel reductions. To parallelize or vectorize a reduction, the programmer has to manually factor the reduction into multiple stages to expose more data parallelism, that, in a sense, violates the core promise of Halide in which algorithm and schedule should be separable and independent of each other. This manipulation of \emph{algorithm} to enable parallel reductions is also bug-prone and may hamper code readability and portability.

In this paper, we present a new Halide scheduling primitive \code{rfactor}, which moves this factoring of a reduction into the \emph{schedule}, while maintaining Halide's correctness and consistency guarantees. \code{rfactor} takes a Halide serial reduction (expressed by unstructured Halide "update" definitions), and synthesizes the equivalent binary associative reduction operator with its identity. The reduction operator can be as simple as summation over one-dimensional vector or some multidimensional reduction operators such as two-dimensional argmin over an image. During the compilation process, \code{rfactor} splits the original stage into pair of stages: the \emph{intermediate} stage that computes partial results over slices of the domain of the reduction and the \emph{merge} stage that combines those partial results . \code{rfactor} introduces new data parallelizable/vectorizable dimensions out of a reduction that enables parallelization or vectorization of a Halide algorithm which was previously not possible. 

Combined with other Halide scheduling primitives, such as \code{split}, this allows Halide to represent a much broader class of schedules, including parallel associative reduction. For example, one might schedule a parallel divide-and-conquer summation over one-dimensional array in Halide by first splitting the array reduction dimension into inner and outer sub-dimensions using \code{split}, then computes the partial sum of the inner subarrays and combines those partial results using \code{rfactor} (See Listing \ref{lst:sum}). In addition to improved code readability and portability (See Listing \ref{lst:complex_magnitude}), \code{rfactor} further supports separation of \emph{algorithm} and \emph{schedule} by moving factorization of a reduction into \emph{schedule}, which is especially important for auto-scheduling \cite{Mullapudi:2016:ASH:2897824.2925952} since auto-scheduling is only allowed to modify \emph{schedule} without changing the \emph{algorithm}.


\begin{lstlisting}[
caption = {make the case that they're both associative reductions, but it's not obvious what the binary operator is from the code for the second one}, label={lst:sum}]
Summation (easy example)

Func out;
out() = 0;
RDom r(0, input.width());
out() = out() + input(r.x);
\end{lstlisting}

\begin{lstlisting}[
caption = {make the case that they're both associative reductions, but it's not obvious what the binary operator is from the code for the second one}, label={lst:complex_magnitude}]
The complex number with the greatest magnitude, 
and its location (hard example)

Func out;
out() = {0, 0, 0};
RDom r(0, input.width(), 0, input.height());
Expr real = input(r.x, r.y)[0];
Expr imag = input(r.x, r.y)[1];
Expr mag = real * real + imag * imag;
Expr best_mag = out()[0] * out()[0] + 
                out()[1] * out()[1];
Expr c = mag > best_mag;
out() = {select(c, real, out()[0]),
         select(c, imag, out()[1]),
         select(c, r.x, out()[2]),
         select(c, r.y, out()[3])};
\end{lstlisting}